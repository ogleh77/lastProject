package com.example.desktopapp.model;

import com.example.desktopapp.entity.Customers;
import com.example.desktopapp.entity.Payments;
import com.example.desktopapp.entity.Users;
import com.example.desktopapp.entity.serices.Box;
import com.example.desktopapp.exceptions.SqlCustomException;
import com.example.desktopapp.helpers.IConnection;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.sql.*;
import java.time.LocalDate;
import java.util.Arrays;

public class PaymentDTO {
    private static Connection connection = IConnection.getConnection();
    public static int limit = 0;

    //---------------------Create new payment-------------––

    public static void insertPayment(String customerPhone, String customerGender, Payments payment) throws SQLException {
        String insertPaymentQuery = "INSERT INTO payments(exp_date, amount_paid, paid_by," +
                "discount,poxing,box_fk, customer_phone_fk) VALUES (?,?,?,?,?,?,?)";
        PreparedStatement ps = connection.prepareStatement(insertPaymentQuery);
        ps.setString(1, payment.expDate().toString());
        ps.setDouble(2, payment.amountPaid());
        ps.setString(3, payment.paidBy());
        ps.setDouble(4, payment.discount());
        ps.setBoolean(5, payment.poxing());
        if (payment.box() == null) {
            ps.setString(6, null);
        } else {
            //Make the box un ready
            setTookBoxIsReadyFalse(payment.box());
            ps.setInt(6, payment.box().boxId());
        }

        ps.setString(7, customerPhone);
        ps.executeUpdate();

        //-------------make the payment's report-------------
        makeReport(payment, customerGender);

        System.out.println("Payment inserted");
    }


//--------------------Insert customer with payment transactionaly----------------------------

    public static void insertCustomerWithPayment(Customers customer, Payments payment) throws SQLException {

        //step 1  set auto commit off
        connection.setAutoCommit(false);
        try {
            //setp 2  create customer
            insertCustomer(customer);
            //step 3 create payment
            PaymentDTO.insertPayment(customer.phone(), customer.gander(), payment);
            //  System.out.println(1 / 0);
            //Finally commit the opertions
            connection.commit();
        } catch (SQLException e) {
            connection.rollback();
            e.printStackTrace();
            throw e;
        }


    }
    //--------------------fetchAll customers according to it's gander--------------

    public static ObservableList<Customers> fetchCustomersWithGender(Users activeUser)
            throws SQLException {
        System.out.println("Limit is " + limit);

        ObservableList<Customers> customers = FXCollections.observableArrayList();

        //----------------------Pass the user's gander and role---------------------
        String fetchingQueryWithGander = userSeparator(activeUser.role(), activeUser.gender());

        Statement statement = connection.createStatement();

        ResultSet rs = statement.executeQuery(fetchingQueryWithGander);


        while (rs.next()) {
            //--------------Load phone of the customer-------------
            String customerPhone = rs.getString("phone");

            //--------------Fetch all the payments that has customer phone-------------
            ObservableList<Payments> payments = fetchPaymentsWhereIsOnline(customerPhone);


            Customers customer = new Customers(rs.getInt("customer_id"), rs.getString("first_name"),
                    rs.getString("middle_name"), rs.getString("last_name"),
                    rs.getString("phone"), rs.getString("gander"),
                    rs.getString("shift"), rs.getString("address"),
                    rs.getString("image"), rs.getDouble("weight"),
                    rs.getString("who_added"), null, null, payments);

            customers.add(customer);
        }


        return customers;
    }

    public static ObservableList<Payments> fetchPaymentsWhereIsOnline(String phone) throws SQLException {

        //------------------------helper methods-------------------------tested.....

        //-------Fetch payments according to customer that belongs--------tested......
        ObservableList<Payments> payments = FXCollections.observableArrayList();
        Statement statement = connection.createStatement();

        Payments payment = null;
        ResultSet rs = statement.executeQuery("SELECT * FROM payments LEFT JOIN box b on payments.box_fk = b.box_id " +
                "WHERE customer_phone_fk=" + phone + " AND is_oline=true ORDER BY exp_date DESC ");

        while (rs.next()) {
            Box box = null;
            if (rs.getString("box_fk") != null) {
                box = new Box(rs.getInt("box_id"), rs.getString("box_name"), rs.getBoolean("is_ready"));
            }

            payment = new Payments(rs.getInt("payment_id"), rs.getString("payment_date"),
                    LocalDate.parse(rs.getString("exp_date")), rs.getString("month"),
                    rs.getString("year"), rs.getDouble("amount_paid"),
                    rs.getString("paid_by"), rs.getDouble("discount"),
                    rs.getBoolean("poxing"), box, rs.getInt("customer_phone_fk"),
                    rs.getBoolean("is_online"), rs.getBoolean("pending"));
            payments.add(payment);
        }
        statement.close();
        rs.close();

        return payments;
    }

    private static String userSeparator(String role, String gander) {
        String fetchQuery = "SELECT * FROM customers WHERE gander='" + gander +
                "'ORDER BY customer_id";

        if (role.equals("superAdmin")) {
            System.out.println("Active customer is " + role);
            fetchQuery = "SELECT * FROM customers ORDER BY customer_id";
        }
        return fetchQuery;
    }

    //-------------------------make report------------------------------
    private static void makeReport(Payments payment, String customerGender) throws SQLException {
        Statement st = connection.createStatement();
        if (customerGender.equals("Male") && payment.box() != null) {
            DailyReportDTO.dailyReportMaleWithBox(st);
        } else if (customerGender.equals("Female") && payment.box() != null) {
            DailyReportDTO.dailyReportFemaleWithBox(st);
        } else if (payment.box() == null && customerGender.equals("Male")) {
            DailyReportDTO.dailyReportMaleWithOutBox(st);
        } else if (payment.box() == null && customerGender.equals("Female")) {
            DailyReportDTO.dailyReportFemaleWithOutBox(st);
        }
        int arr[] = st.executeBatch();
        System.out.println(Arrays.toString(arr));
        st.close();
    }

    private static void insertCustomer(Customers customer) throws SQLException {
        try {
            String insertQuery = "INSERT INTO customers(first_name, middle_name, last_name, phone, gander, shift, address, image, weight, who_added)\n" + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
            PreparedStatement ps = connection.prepareStatement(insertQuery);

            ps.setString(1, customer.firstname());
            ps.setString(2, customer.middleName());
            ps.setString(3, customer.lastName());
            ps.setString(4, customer.phone());
            ps.setString(5, customer.gander());
            ps.setString(6, customer.shift());
            ps.setString(7, customer.address());
            ps.setString(8, customer.image());
            ps.setDouble(9, customer.weight());
            ps.setString(10, customer.whoAdded());

            ps.executeUpdate();
            ps.close();
            System.out.println("Customer added");
        } catch (SQLException e) {
            if (e.getMessage().contains("(UNIQUE constraint failed: customers.phone)"))
                throw new SqlCustomException("Lanbarkan hore ayaa lo isticmalay fadlan hubi");
        }

    }

    //fetch single payment
    public static Payments payment(int paymentId) throws SQLException {
        Statement statement = connection.createStatement();

        Payments payment = null;
        ResultSet rs = statement.executeQuery("SELECT * FROM payments LEFT JOIN box b on payments.box_fk = b.box_id " +
                "WHERE payment_id=" + paymentId);

        while (rs.next()) {
            Box box = null;
            if (rs.getString("box_fk") != null) {
                box = new Box(rs.getInt("box_id"), rs.getString("box_name"), rs.getBoolean("is_ready"));
            }
            payment = new Payments(rs.getInt("payment_id"), rs.getString("payment_date"),
                    LocalDate.parse(rs.getString("exp_date")), rs.getString("month"),
                    rs.getString("year"), rs.getDouble("amount_paid"),
                    rs.getString("paid_by"), rs.getDouble("discount"),
                    rs.getBoolean("poxing"), box, rs.getInt("customer_phone_fk"),
                    rs.getBoolean("is_online"), rs.getBoolean("pending"));
        }
        return payment;
    }


    //-----------------------Box operations------------------

    private static void setTookBoxIsReadyFalse(Box box) throws SQLException {
        String boxFalseQuery = "UPDATE box SET is_ready=false WHERE box_id=" + box.boxId();
        Statement statement = connection.createStatement();
        statement.executeUpdate(boxFalseQuery);
        System.out.println(box.boxName() + " made false");
    }

    private static void setBoxIsReadyTrue(Box box) throws SQLException {
        String boxFalseQuery = "UPDATE box SET is_ready=true WHERE box_id=" + box.boxId();
        Statement statement = connection.createStatement();
        statement.executeUpdate(boxFalseQuery);
        System.out.println(box.boxName() + " made false");
    }

    private static void paymentIsOutDated(Payments payment) throws SQLException {
        connection.setAutoCommit(false);
        try {
            String outDatedPaymentQuery = "UPDATE payments set is_online=false WHERE payment_id=" + payment.paymentId();
            Statement statement = connection.createStatement();
            statement.executeUpdate(outDatedPaymentQuery);

            if (payment.box() != null) {
                setBoxIsReadyTrue(payment.box());
            }

            connection.commit();
            System.out.println("Connection outdated...");
        } catch (SQLException e) {
            connection.rollback();
            throw e;
        }
    }


}
